package com.macasaet;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import org.junit.jupiter.api.Test;

/**
 * --- Day 9: Smoke Basin ---
 */
public class Day09 {

    protected Stream<String> getInput() {
        return StreamSupport
                .stream(new LineSpliterator("day-09.txt"),
                        false);
    }

    public HeightMap getHeightMap() {
        final var list = getInput().map(line -> {
            final var chars = line.toCharArray();
            final var ints = new int[chars.length];
            for (int i = chars.length; --i >= 0; ints[i] = chars[i] - '0') ;
            return ints;
        }).collect(Collectors.toList());
        final int[][] grid = new int[list.size()][];
        for (int i = list.size(); --i >= 0; grid[i] = list.get(i)) ;
        return new HeightMap(grid);
    }

    /**
     * A height map of the floor of the nearby caves generated by the submarine
     */
    public record HeightMap(int[][] grid) { // FIXME use bytes

        public Stream<Point> points() {
            return IntStream.range(0, grid().length)
                    .boxed()
                    .flatMap(i -> IntStream.range(0, grid()[i].length)
                            .mapToObj(j -> new Point(i, j)));
        }

        /**
         * A location on the floor of a nearby cave
         */
        public class Point {
            final int x;
            final int y;

            public Point(final int x, final int y) {
                this.x = x;
                this.y = y;
            }

            public int x() {
                return this.x;
            }

            public int y() {
                return this.y;
            }

            public int getBasinSize() {
                return getBasinPoints().size();
            }

            /**
             * Identify all the higher points that are also part of the same basin, assuming this location is part of a
             * basin.
             *
             * @return all the higher points, if any, that are part of the same basin.
             */
            public Set<Point> getBasinPoints() {
                if (getHeight() >= 9) {
                    return Collections.emptySet();
                }
                final var result = new HashSet<Point>();
                result.add(this);
                final Function<Point, Stream<Point>> basinPointRetriever = neighbour -> {
                    if (neighbour.getHeight() >= 9 || neighbour.getHeight() <= getHeight() || result.contains(neighbour)) {
                        return Stream.empty();
                    }
                    return neighbour.getBasinPoints().stream();
                };
                above().stream().flatMap(basinPointRetriever).forEach(result::add);
                below().stream().flatMap(basinPointRetriever).forEach(result::add);
                left().stream().flatMap(basinPointRetriever).forEach(result::add);
                right().stream().flatMap(basinPointRetriever).forEach(result::add);
                return Collections.unmodifiableSet(result);
            }

            /**
             * @return true if and only if this location is lower than all of its adjacent locations (up to four,
             * diagonals do not count)
             */
            public boolean isLowPoint() {
                final var compareTo = new ArrayList<Point>(4);
                above().ifPresent(compareTo::add);
                below().ifPresent(compareTo::add);
                left().ifPresent(compareTo::add);
                right().ifPresent(compareTo::add);
                return compareTo.stream().allMatch(neighbour -> neighbour.getHeight() > getHeight());
            }

            /**
             * @return an assessment of the risk from smoke flowing through the cave
             */
            public int getRiskLevel() {
                return getHeight() + 1;
            }

            /**
             * @return the height of this particular location, from 0-9
             */
            public int getHeight() {
                return grid()[x()][y()];
            }

            public Optional<Point> above() {
                return x() > 0 ? Optional.of(new Point(x() - 1, y())) : Optional.empty();
            }

            public Optional<Point> below() {
                return x() < grid().length - 1 ? Optional.of(new Point(x() + 1, y())) : Optional.empty();
            }

            public Optional<Point> left() {
                return y() > 0 ? Optional.of(new Point(x(), y() - 1)) : Optional.empty();
            }

            public Optional<Point> right() {
                return y() < grid()[x()].length - 1 ? Optional.of(new Point(x(), y() + 1)) : Optional.empty();
            }

            public int hashCode() {
                return Objects.hash(x(), y());
            }

            public boolean equals(final Object o) {
                try {
                    final Point other = (Point) o;
                    return this.x() == other.x() && this.y() == other.y();
                } catch (final ClassCastException cce) {
                    return false;
                }
            }
        }

    }

    @Test
    public final void part1() {
        final var map = getHeightMap();
        final int sum = map.points()
                .filter(HeightMap.Point::isLowPoint)
                .mapToInt(HeightMap.Point::getRiskLevel)
                .sum();
        System.out.println("Part 1: " + sum);
    }

    @Test
    public final void part2() {
        final var map = getHeightMap();
        final var basinSizes = map.points()
                .filter(HeightMap.Point::isLowPoint)
                .mapToInt(HeightMap.Point::getBasinSize)
                .collect(() -> new TreeSet<Integer>(Comparator.reverseOrder()), SortedSet::add, SortedSet::addAll);
        final var iterator = basinSizes.iterator();
        final var result = iterator.next() * iterator.next() * iterator.next();
        System.out.println("Part 2: " + result);
    }

}